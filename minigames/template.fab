//-----------------------------------------------------------------------------
//
// YOU MUST DEFINE THESE GLOBALS:
// '_directions':      An array of direction strings.
// '_initial_palette': The palette to be loaded at the start of your minigame.
// '_setup':           A function called before your minigame starts.
// '_nmi':             A function called at the start of VBLANK.
// '_prepare_sprites': A function called to assign the 'oam' buffer.
// '_loop':            A function called every frame.
// Additionally, a "minigame" macro invocation must occur in this file!
//
// YOU MUST ALSO EDIT:
// 'minigame_list.fab': Add your minigame's identifier to the list!
//
// THINGS TO AVOID:
// (1) Non-private global identifiers. By default, NESFab makes global 
//     definitions visible to any and all files. This is bad, as it means your 
//     code could interfere with someone else's. To prevent this, prefix all
//     global identifiers with an underscore: '_', like '_my_var'.
//     Such identifiers will not be exported to other files.
// (2) Multiple files. This would require breaking (1), so keep all your
//     code in a single file.
// (3) Using the 'state' keyword. This breaks the Fabioware runtime!
// (4) Changing modes. This breaks the Fabioware runtime!
// (5) Using the APU or PUF. The only permitted way to play sounds is 
//     with the function 'play_sound'.
//
//-----------------------------------------------------------------------------

// This macro invocation is required.
// The first argument must be "minigame".
// The second argument is the unique identifier to recognize your minigame by.
// The third argument are the short directions of your minigame.
macro("minigame", "my_identifier")
: +fork_scope   // This modifier is required!

// Put global variables here:
vars /_

// '_directions' are a list of possible direction strings.
// The FabioWare runtime will randomly select a string to display before the
// minigame starts. Typically, your minigame will only have a single string,
// but you could have more if you have randomized goals.
ct CCC/strings[] _directions = CCC/strings[](@"Do the thing!")

data /palette
    // '_initial_palette' is the palette used at the start of your minigame.
    // Of course, you may change the palette later on,
    // but this is the initial state.
    [] _initial_palette
        // Background colors:
        U[3]($0F, $0F, $0F)
        U[3]($0F, $0F, $0F)
        U[3]($0F, $0F, $0F)
        U[3]($0F, $0F, $0F)
        // Sprite colors:
        U[3]($0F, $0F, $0F)
        U[3]($0F, $0F, $0F)
        U[3]($0F, $0F, $0F)
        U[3]($0F, $0F, $0F)
        // Universal background color:
        U($0F)

// '_setup' is called before your minigame starts.
// Put any special initialization code here, 
// such as determining the random positions of objects.
// The first parameter corresponds to the random direction chosen from
// the '_directions' array.
// NOTE: Rendering and NMI are OFF during '_setup'; do not turn them on!
fn _setup(U direction_index)

// '_nmi' is called once per frame, at the start of NMI.
// NOTE: Several aspects of the NMI are already handled for you, specifically
//       the palette, OAM, music engine, and controller updates.
fn _nmi()
    // Update the registers before returning:
    ppu_set_scroll(0, 0)
    {PPUCTRL}(PPUCTRL_NMI_ON)
    {PPUMASK}(PPUMASK_ON | PPUMASK_NO_CLIP)

// '_prepare_sprites' is called to assign the 'oam' buffer.
// This occurs both after `_setup`, and after `_loop`.
fn _prepare_sprites()

// '_loop' is called once per frame, while your minigame is running.
// Put all your game logic here, handling user input and so on.
fn _loop()

